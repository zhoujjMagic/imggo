
#### NumPy（Numerical Python的简称）
NumPy是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。

NumPy的部分功能如下：

- ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。
- 用于对整组数据进行快速运算的标准数学函数（无需编写循环）。
- 用于读写磁盘数据的工具以及用于操作内存映射文件的工具。
- 线性代数、随机数生成以及傅里叶变换功能。
- 用于集成由C、C++、Fortran等语言编写的代码的A C API。

#### NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：

- NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。
- NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。

##### 具体的性能差距，通过考察一个包含一百万整数的数组，和一个等价的Python列表：


```python
# 导入Numpy
import numpy as np
import random
# 不使用默认的科学计数法显示数字，使用小数显示
np.set_printoptions(suppress=True)
```


```python
# list列表
list_ = [random.randint(50,100) for i in range(1000000)]
%time result = sum(list_)
```

    Wall time: 8 ms
    


```python
# np.ndarray的性能比list_好
ndarray = np.arange(1000000)
%time result2 = np.sum(ndarray)
```

    Wall time: 3 ms
    

##### 总结：基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。

 #### NumPy的ndarray：一种多维数组对象
 NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。


```python
prices = [
    [1, 2, 3, 4, 5, 6, 7, 8, 9],
    [11, 12, 13, 14, 15, 16, 17, 18, 19],
    [21, 22, 23, 24, 25, 26, 27, 28, 29],
    [31, 32, 33, 34, 35, 36, 37, 38, 39],
]
```


```python
ndarray = np.array([[1,2,3],[4,5,6]])  # <class 'numpy.ndarray'>
print(type(ndarray))
ndarray.size
```

    <class 'numpy.ndarray'>
    




    6




```python
# 将列表转换为numpy的ndarray对象
prices_ndarray = np.array(prices)
print('prices_ndarray：\n', prices_ndarray)
# 获取ndarray的形状(4, 9)
shape = prices_ndarray.shape
print('形状shape：', shape)
# 获取ndarray的维数2
ndim = prices_ndarray.ndim
print('维数ndim：', ndim)
# 获取ndarray的元素个数36
size = prices_ndarray.size
print('包含元素个数size：', size)
# 获取ndarray的每个元素的字节长度  4
itemsize = prices_ndarray.itemsize
print('每元素字节长度itemsize：',itemsize)
# 获取ndarray的每个元素的类型 int32
type = prices_ndarray.dtype
print('每个元素类型dtype：', type)
```

    prices_ndarray：
     [[ 1  2  3  4  5  6  7  8  9]
     [11 12 13 14 15 16 17 18 19]
     [21 22 23 24 25 26 27 28 29]
     [31 32 33 34 35 36 37 38 39]]
    形状shape： (4, 9)
    维数ndim： 2
    包含元素个数size： 36
    每元素字节长度itemsize： 4
    每个元素类型dtype： int32
    

如何理解数组的维度，可以使用excel表比喻


```python
# 一维
arr_1d = np.array([1, 2, 3])
arr_1d.shape
```




    (3,)




```python
# 二维
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
arr_2d.shape
```




    (2, 3)




```python
# 三维
arr_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr_3d.shape
```




    (2, 2, 3)



##### 1.1创建ndarray
创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：


```python
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)  # 默认自己推断数据类型，也可以使用dtyp参数指定数据类型
arr1.dtype
```




    dtype('float64')




```python
data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
```




    array([[1, 2, 3, 4],
           [5, 6, 7, 8]])




```python
arr1.ndim
```




    1




```python
arr2.ndim
```




    2



除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：


```python
# np.zeros((3,4))
# np.ones((1,2,3))
# np.ones_like([1,2,3])
```


```python
np.zeros((3, 6))
```




    array([[0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0.]])




```python
np.empty((2, 3, 2))
```




    array([[[0., 0.],
            [0., 0.],
            [0., 0.]],
    
           [[0., 0.],
            [0., 0.],
            [0., 0.]]])




```python
np.eye(3,3)
```




    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])




```python
arr4 = np.asarray(data1, dtype=np.int32)
arr4 = arr4.astype(np.int64)
arr4.dtype
```




    dtype('int64')



##### 1.2 ndarray的数据类型

dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：


```python
arr1 = np.array([1, 2, 3], dtype=np.float64)
arr2 = np.array([1, 2, 3], dtype=np.int32)
```


```python
arr1.dtype
```




    dtype('float64')




```python
arr2.dtype
```




    dtype('int32')



>笔记：记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），那就得了解如何控制存储类型。

![image.png](attachment:image.png)

![image.png](attachment:image.png)

可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：


```python
arr = np.array([1, 2, 3, 4, 5])
arr.dtype
```




    dtype('int32')




```python
float_arr = arr.astype(np.float64)
float_arr.dtype
```




    dtype('float64')



注意：整数被转换成浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：


```python
arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
arr
```




    array([ 3.7, -1.2, -2.6,  0.5, 12.9, 10.1])




```python
arr2 = arr.astype(np.int32)
arr2
```




    array([ 3, -1, -2,  0, 12, 10])



##### 1.3 Numpy数组的运算

数组很重要，因为它使你不用编写循环即可对数据执行批量运算。

大小相等的数组之间的任何算术运算都会将运算应用到元素级：


```python
arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
arr * arr
```




    array([[ 1.,  4.,  9.],
           [16., 25., 36.]])




```python
arr -arr
```




    array([[0., 0., 0.],
           [0., 0., 0.]])



数组与标量的算术运算会将标量值传播到各个元素：


```python
1 / arr
```




    array([[1.        , 0.5       , 0.33333333],
           [0.25      , 0.2       , 0.16666667]])




```python
 arr ** 2
```




    array([[ 1.,  4.,  9.],
           [16., 25., 36.]])



大小相同的数组之间的比较会生成布尔值数组：


```python
arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])
arr2
```




    array([[ 0.,  4.,  1.],
           [ 7.,  2., 12.]])




```python
arr
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
arr2 > arr
```




    array([[False,  True, False],
           [ True, False,  True]])




```python
arr3 = np.array([1,3])
arr3
```




    array([1, 3])




```python
arr3.shape
```




    (3,)




```python
arr2.shape
```




    (3, 3)




```python
arr3 + arr2
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-152-ac91be2b6918> in <module>
    ----> 1 arr3 + arr2
    

    ValueError: operands could not be broadcast together with shapes (2,) (3,3) 


不同大小的数组之间的运算叫做广播（broadcasting）

##### 广播（broadcasting）
 广播（broadcasting）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：


```python
arr = np.arange(5)
arr
```




    array([0, 1, 2, 3, 4])




```python
arr * 4  # 在这个乘法运算中，标量值4被广播到了其他所有的元素上。
```




    array([ 0,  4,  8, 12, 16])




```python
# 我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：
arr = np.random.randn(4, 3)
arr
```




    array([[ 0.66732932, -1.05212212,  0.41359531],
           [ 0.50875986, -2.16109881, -0.56781924],
           [ 0.9572355 ,  0.61554363,  1.27529975],
           [-0.16007612, -0.78543079,  1.9361187 ]])




```python
arr.mean(0)  # 0轴代表行变列不变，1轴代表列变行不变
```




    array([ 0.49331214, -0.84577702,  0.76429863])




```python
demeaned = arr - arr.mean(0)
demeaned
```




    array([[ 0.17401718, -0.2063451 , -0.35070332],
           [ 0.01544772, -1.31532179, -1.33211787],
           [ 0.46392336,  1.46132066,  0.51100112],
           [-0.65338826,  0.06034623,  1.17182007]])




```python
demeaned.mean(0)
```




    array([0., 0., 0.])



图A-4形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。
![image.png](attachment:image.png)

于是得到：
![image.png](attachment:image.png)

![image.png](attachment:image.png)
![image.png](attachment:image.png)

数组与数组之间进行计算需要满足广播机制, 即：维度相应位置相同或者有一个为1。                                        
可以计算: [2, 3, 5]和[5]、[3, 5]、[2, 3, 5]、[1, 3, 5]、[3, 1]、[1, 1, 1]等       
不能计算: [2, 3, 5]和[4]、[2, 1]、[2, 1, 3]等

##### 1.4 基本的索引和切片

NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：


```python
arr = np.arange(10)
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr[-1]  # 取索引为5的元素
```




    9




```python
arr[1:4:2]  # 取索引为5、6、7的元素，不包含索引8
```




    array([1, 3])




```python
arr[::2] = 12
arr
```




    array([12,  1, 12,  3, 12,  5, 12,  7, 12,  9])



对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：


```python
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
```




    array([7, 8, 9])




```python
arr2d[0][2]
```




    3




```python
 arr2d[0, 2]
```




    3



下图说明了二维数组的索引方式。轴0作为行，轴1作为列。
![image.png](attachment:image.png)


```python
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d.shape
```




    (2, 2, 3)




```python
 arr3d[0, 0, 0]
```




    1



##### 切片索引
ndarray的切片语法跟Python列表这样的一维对象差不多：


```python
arr = np.array([ 0,  1,  2,  3,  4, 5, 6, 7,  8,  9])
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr[1:6]
```




    array([1, 2, 3, 4, 5])




```python
arr2d = np.arange(12).reshape(3, 4)
arr2d
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])




```python
# 可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。
# 表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。
arr2d[:2]  
```




    array([[0, 1, 2, 3],
           [4, 5, 6, 7]])




```python
# 你可以一次传入多个切片，就像传入多个索引那样：
arr2d[:2, 1:]
```




    array([[1, 2, 3],
           [5, 6, 7]])




```python
arr2d[1, :2]
```




    array([4, 5])




```python
arr2d[:2, 2]
```




    array([2, 6])




```python
 arr2d[:, :1]
```




    array([[0],
           [4],
           [8]])




```python
##### 二维数组切片
```

![image.png](attachment:image.png)


```python
# 自然，对切片表达式的赋值操作也会被扩散到整个选区：
arr2d[:2, 1:] = 0
arr2d
```




    array([[ 0,  0,  0,  0],
           [ 4,  0,  0,  0],
           [ 8,  9, 10, 11]])



##### 布尔型索引
假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np.random.randn(7, 4)
names
```




    array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')




```python
names == 'Bob'
```




    array([ True, False, False,  True, False, False, False])




```python
data
```




    array([[ 1.13558464,  1.04380455,  0.58471287, -0.91037536],
           [-0.76087312,  0.09932098, -1.39340707, -0.05096369],
           [ 0.07266387,  1.117594  ,  0.33693575, -0.49316917],
           [-1.01626682, -0.44820096, -1.34563749, -1.00107832],
           [ 0.90570956,  0.59634103, -0.3053516 , -0.24214563],
           [ 0.05172374, -0.57973175,  1.23450956,  0.43662639],
           [ 0.46594235,  0.21135191, -0.15368918, -1.89180126]])




```python
data[names == 'Bob']
```




    array([[ 1.13558464,  1.04380455,  0.58471287, -0.91037536],
           [-1.01626682, -0.44820096, -1.34563749, -1.00107832]])



>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此布尔型数组的长度必须跟被索引的轴长度一致。

还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用,下面选取``names == 'Bob'``的行，并索引了列：


```python
data[names == 'Bob', 2:]
```




    array([[-0.50872651,  1.19561689],
           [ 0.61846049,  0.63454766]])



选择除"Bob"以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定：


```python
names != 'Bob'
```




    array([False,  True,  True, False,  True,  True,  True])




```python
data[~(names == 'Bob')]  # ~表示取反
```




    array([[-0.84954111,  0.08897   , -0.04866233,  0.43200058],
           [-0.30575411,  0.55741258,  0.27557361, -1.00956791],
           [-0.65083588,  0.53071026,  1.00213789,  0.88397029],
           [-2.07062243,  0.51689753, -0.47115111, -1.07583916],
           [ 0.15948194,  1.22107379, -1.48406588, -0.13498585]])



选取这三个名字中的两个需要组合应用多个布尔条件，使用&（和）、|（或）之类的布尔算术运算符即可：


```python
mask = (names == 'Bob') | (names == 'Will')
```


```python
data[mask]
```




    array([[-1.19016549, -2.37457788, -0.50872651,  1.19561689],
           [-0.30575411,  0.55741258,  0.27557361, -1.00956791],
           [ 0.43254627, -0.60721224,  0.61846049,  0.63454766],
           [-0.65083588,  0.53071026,  1.00213789,  0.88397029]])



>注意：通过布尔型索引选取数组中的数据，将总是创建数据的副本,Python关键字and和or在布尔型数组中无效。要使用&与|。

##### 花式索引


```python
arr = np.random.randint(1,10,(8, 4))
arr
```




    array([[6, 1, 9, 1],
           [1, 9, 8, 4],
           [7, 8, 5, 1],
           [5, 9, 1, 6],
           [2, 9, 3, 9],
           [8, 2, 7, 9],
           [9, 3, 5, 4],
           [5, 7, 1, 5]])




```python
arr[[4, 3, 0, 6]]
```




    array([[2, 9, 3, 9],
           [5, 9, 1, 6],
           [6, 1, 9, 1],
           [9, 3, 5, 4]])




```python
arr[[-3, -5, -7]]
```




    array([[8, 2, 7, 9],
           [5, 9, 1, 6],
           [1, 9, 8, 4]])




```python
arr = np.arange(32).reshape((8, 4))
arr
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15],
           [16, 17, 18, 19],
           [20, 21, 22, 23],
           [24, 25, 26, 27],
           [28, 29, 30, 31]])




```python
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
```




    array([ 4, 23, 29, 10])




```python
 arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])



##### 数组转置和轴对换
转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：


```python
arr = np.arange(1, 10).reshape((3,3))
arr
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
arr.T
```




    array([[1, 4, 7],
           [2, 5, 8],
           [3, 6, 9]])



在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：


```python
# arr = np.random.randn(6, 3)
# arr
```


```python
np.dot(arr.T, arr)
```




    array([[ 66,  78,  90],
           [ 78,  93, 108],
           [ 90, 108, 126]])



#### 通用函数
用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。


```python
arr = np.arange(10)
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.sqrt(arr)
```




    array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
           2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])




```python
np.exp(arr)   # e:
```




    array([   1.        ,    2.71828183,    7.3890561 ,   20.08553692,
             54.59815003,  148.4131591 ,  403.42879349, 1096.63315843,
           2980.95798704, 8103.08392758])




```python
x = np.random.randn(8)
y = np.random.randn(8)    
```


```python
x
```




    array([-1.12770756,  0.38023727, -0.4450719 ,  1.04156009,  0.53787487,
           -1.10197095,  0.60701719,  0.94237174])




```python
y
```




    array([ 0.03057567, -1.1030502 ,  2.51088807, -0.81974468, -0.33674527,
            0.33043106,  2.59248751, -0.00433006])




```python
np.maximum(x, y)   # 这里，numpy.maximum计算了x和y中元素级别最大的元素。
```




    array([0.03057567, 0.38023727, 2.51088807, 1.04156009, 0.53787487,
           0.33043106, 2.59248751, 0.94237174])




```python
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])
```


```python
result = np.where(cond, xarr, yarr)  # np.where的第二个和第三个参数不必是数组，它们都可以是标量值。
result
```




    array([1.1, 2.2, 1.3, 1.4, 2.5])



##### 数学和统计方法
以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。


```python
# 生成一些正态分布随机数据，然后做了聚类统计：
arr = np.random.randn(5, 4)
arr
```




    array([[-0.52937897,  0.11499388, -1.41481901,  0.04796413],
           [-0.23560045,  0.56929375, -1.19036137,  0.97661387],
           [ 0.80561761, -0.84561863,  0.09188155, -1.01486162],
           [-0.62254497, -0.75998023,  0.94157747, -1.22538591],
           [-1.23340116, -1.19691552,  0.13938677,  0.17895383]])




```python
arr.mean()
# np.mean(arr)
```




    -0.3201292496472475




```python
arr.sum()
```




    -6.402584992944949




```python
arr.mean(axis=1)  # axis=1 列变行不变
```




    array([-0.44531   ,  0.02998645, -0.24074527, -0.41658341, -0.52799402])




```python
arr.mean(axis=0)  # axis=0 行变列不变
```




    array([-0.36306159, -0.42364535, -0.28646692, -0.20734314])




```python
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7])
arr.cumsum()
```




    array([ 0,  1,  3,  6, 10, 15, 21, 28], dtype=int32)



下图列出了全部的基本数组统计方法。

![image.png](attachment:image.png)

##### 排序
跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：


```python
arr = np.random.randn(6)
arr
```




    array([ 0.62440706,  0.55815359,  1.09451984, -0.53447996,  0.41457957,
            0.5288351 ])




```python
arr.sort()
arr
```




    array([-0.53447996,  0.41457957,  0.5288351 ,  0.55815359,  0.62440706,
            1.09451984])




```python
# 多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：
arr = np.random.randn(5, 3)
arr
```




    array([[-1.93218269, -1.76416981, -0.36130033],
           [-0.33170836,  0.46269702, -1.08925563],
           [-0.34365914, -0.45732281, -0.32508209],
           [-0.66160911,  0.68668486, -0.09023877],
           [ 0.51599768,  0.50373357,  1.53902437]])




```python
# arr.sort(axis=1)  # 默认升序
arr2 = np.sort(-arr, 1)*-1  # 降序
arr2
```




    array([[-0.36130033, -1.76416981, -1.93218269],
           [ 0.46269702, -0.33170836, -1.08925563],
           [-0.32508209, -0.34365914, -0.45732281],
           [ 0.68668486, -0.09023877, -0.66160911],
           [ 1.53902437,  0.51599768,  0.50373357]])




```python
arr
```




    array([[-1.93218269, -1.76416981, -0.36130033],
           [-0.33170836,  0.46269702, -1.08925563],
           [-0.34365914, -0.45732281, -0.32508209],
           [-0.66160911,  0.68668486, -0.09023877],
           [ 0.51599768,  0.50373357,  1.53902437]])



##### 改变数组的维度
- reshape   改变数组的形状
- resize   和reshape一样，但resize会直接修改所操作的数组。
- ravel    展平数组
- flatten   展平数组
- transpose  


```python
nd = np.arange(24).reshape(2,3,4)
nd
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],
    
           [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])




```python
# 改变数组的维度
nd.ravel()
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23])




```python
nd.flatten()
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23])




```python
nd.shape
```




    (2, 3, 4)




```python
nd2 = nd.reshape((4,6))
```


```python
nd2.shape
```




    (4, 6)




```python
nd.resize((4,6))
```


```python
nd.shape
```




    (4, 6)



##### 数组的组合

NumPy数组有水平组合、垂直组合和深度组合等多种组合方式，我们将使用vstack、
dstack、hstack、column_stack、row_stack以及concatenate函数来完成数组的组合。


```python
arra = np.arange(9).reshape(3,3)
arra
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
arrb = arra * 2
arrb
```




    array([[ 0,  2,  4],
           [ 6,  8, 10],
           [12, 14, 16]])




```python
# 水平组合
np.hstack((arra, arrb))
```




    array([[ 0,  1,  2,  0,  2,  4],
           [ 3,  4,  5,  6,  8, 10],
           [ 6,  7,  8, 12, 14, 16]])




```python
# 垂直组合
np.vstack((arra, arrb))
```




    array([[ 0,  1,  2],
           [ 3,  4,  5],
           [ 6,  7,  8],
           [ 0,  2,  4],
           [ 6,  8, 10],
           [12, 14, 16]])




```python
# 深度组合
np.dstack((arra,arrb))
```




    array([[[ 0,  0],
            [ 1,  2],
            [ 2,  4]],
    
           [[ 3,  6],
            [ 4,  8],
            [ 5, 10]],
    
           [[ 6, 12],
            [ 7, 14],
            [ 8, 16]]])



##### 数组分割


```python
# 水平分割
np.hsplit(arra, 3)
```




    [array([[0],
            [3],
            [6]]), array([[1],
            [4],
            [7]]), array([[2],
            [5],
            [8]])]




```python
# 垂直分割
np.vsplit(arra, 3)
```




    [array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]




```python
# np.split(arra, 3, axis=1)
# np.split(arra,3, axis=0)
```


```python

```

##### 唯一化以及其它的集合逻辑
NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names)
```




    array(['Bob', 'Joe', 'Will'], dtype='<U4')




```python
ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
np.unique(ints)
```




    array([1, 2, 3, 4])



#### 线性代数
线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：


```python
x = np.array([[1., 2., 3.], [4., 5., 6.]])
y = np.array([[6., 23.], [-1, 7], [8, 9]])
```


```python
x
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
y
```




    array([[ 6., 23.],
           [-1.,  7.],
           [ 8.,  9.]])




```python
x.dot(y)
```




    array([[ 28.,  64.],
           [ 67., 181.]])




```python
np.dot(x, y)
```




    array([[ 28.,  64.],
           [ 67., 181.]])




```python
x @ y
```




    array([[ 28.,  64.],
           [ 67., 181.]])




```python
# 一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：
np.dot(x, np.ones(3))
```




    array([ 6., 15.])




```python
# numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库
```


```python
from numpy.linalg import inv, qr, det
X = np.random.randn(5, 5)
```


```python
det(X)  # 获取X行列式的值
```




    5.1431053594894856




```python
mat = X.T.dot(X)
```


```python
mat
```




    array([[ 3.5810583 , -2.59984335,  0.24619747,  0.7590682 ,  0.1055192 ],
           [-2.59984335,  8.16020745,  1.39243479,  0.87065782,  3.08246046],
           [ 0.24619747,  1.39243479,  2.76261952,  0.72618886,  0.73449717],
           [ 0.7590682 ,  0.87065782,  0.72618886,  1.9435879 ,  2.94820607],
           [ 0.1055192 ,  3.08246046,  0.73449717,  2.94820607,  5.42109856]])




```python
inv(mat)
```




    array([[ 0.52391584,  0.10964079,  0.01695436, -0.83713285,  0.38042854],
           [ 0.10964079,  0.33562504, -0.22917145,  0.78874648, -0.59087314],
           [ 0.01695436, -0.22917145,  0.59940972, -1.15328937,  0.67596869],
           [-0.83713285,  0.78874648, -1.15328937,  7.6409064 , -4.43135737],
           [ 0.38042854, -0.59087314,  0.67596869, -4.43135737,  2.83139256]])




```python
mat.dot(inv(mat))
```




    array([[ 1., -0.,  0., -0.,  0.],
           [-0.,  1.,  0., -0.,  0.],
           [ 0., -0.,  1., -0.,  0.],
           [ 0., -0.,  0.,  1.,  0.],
           [ 0.,  0.,  0., -0.,  1.]])



####  文件读取


```python
arr = np.loadtxt('data/BeijingPM20100101_20151231.csv', delimiter=',', dtype='str', skiprows=1,encoding='utf8')
arr
```




    array([['1', '2010', '1', ..., '1.79', '0', '0'],
           ['2', '2010', '1', ..., '4.92', '0', '0'],
           ['3', '2010', '1', ..., '6.71', '0', '0'],
           ...,
           ['52582', '2015', '12', ..., '0.89', '0', '0'],
           ['52583', '2015', '12', ..., '1.78', '0', '0'],
           ['52584', '2015', '12', ..., '2.67', '0', '0']], dtype='<U11')




```python
beijingdata = np.array([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]])
for i in arr:
    if i[6] != 'NA' and i[7] != 'NA' and i[8] != 'NA':
        beijingdata = np.append(beijingdata, [i], axis=0)
# 文件的保存
np.savetxt('data/beijing.csv', beijingdata, fmt='%s', delimiter=',')
print(beijingdata)
```

    [['1' '2' '3' ... '16' '17' '18']
     ['27825' '2013' '3' ... '0.89' '0' '0']
     ['27826' '2013' '3' ... '1.78' '0' '0']
     ...
     ['52581' '2015' '12' ... '8.03' '0' '0']
     ['52582' '2015' '12' ... '0.89' '0' '0']
     ['52583' '2015' '12' ... '1.78' '0' '0']]
    


```python
scores = np.arange(100)
```


```python
scores
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
           34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
           51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
           68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
           85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])




```python
scores[[1,2]] = -100
```


```python
scores
```




    array([   0, -100, -100,    3,    4,    5,    6,    7,    8,    9,   10,
             11,   12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
             22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
             33,   34,   35,   36,   37,   38,   39,   40,   41,   42,   43,
             44,   45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
             55,   56,   57,   58,   59,   60,   61,   62,   63,   64,   65,
             66,   67,   68,   69,   70,   71,   72,   73,   74,   75,   76,
             77,   78,   79,   80,   81,   82,   83,   84,   85,   86,   87,
             88,   89,   90,   91,   92,   93,   94,   95,   96,   97,   98,
             99])




```python
scores < 0
```




    array([False,  True,  True, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False, False, False, False, False, False, False, False, False,
           False])




```python
scores[scores < 0] = 0
```


```python
scores
```




    array([ 0,  0,  0,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
           34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
           51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
           68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
           85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])




```python
arr1 = np.arange(9).reshape(3,3)
arr1
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
arr2 = np.arange(9, 18).reshape(3, 3)
arr2
```




    array([[ 9, 10, 11],
           [12, 13, 14],
           [15, 16, 17]])




```python
np.hstack((arr1, arr2))
```




    array([[ 0,  1,  2,  9, 10, 11],
           [ 3,  4,  5, 12, 13, 14],
           [ 6,  7,  8, 15, 16, 17]])




```python
# np.hstack((arr1, arr2))
np.hsplit(arr1,3)
```




    [array([[0],
            [3],
            [6]]), array([[1],
            [4],
            [7]]), array([[2],
            [5],
            [8]])]




```python

```
